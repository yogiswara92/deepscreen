{
  "version": 3,
  "sources": ["../../regexparam/dist/index.mjs", "../../svelte-spa-router/Router.svelte"],
  "sourcesContent": ["export function parse(str, loose) {\n\tif (str instanceof RegExp) return { keys:false, pattern:str };\n\tvar c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');\n\tarr[0] || arr.shift();\n\n\twhile (tmp = arr.shift()) {\n\t\tc = tmp[0];\n\t\tif (c === '*') {\n\t\t\tkeys.push('wild');\n\t\t\tpattern += '/(.*)';\n\t\t} else if (c === ':') {\n\t\t\to = tmp.indexOf('?', 1);\n\t\t\text = tmp.indexOf('.', 1);\n\t\t\tkeys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );\n\t\t\tpattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';\n\t\t\tif (!!~ext) pattern += (!!~o ? '?' : '') + '\\\\' + tmp.substring(ext);\n\t\t} else {\n\t\t\tpattern += '/' + tmp;\n\t\t}\n\t}\n\n\treturn {\n\t\tkeys: keys,\n\t\tpattern: new RegExp('^' + pattern + (loose ? '(?=$|\\/)' : '\\/?$'), 'i')\n\t};\n}\n\nvar RGX = /(\\/|^)([:*][^/]*?)(\\?)?(?=[/.]|$)/g;\n\n// error if key missing?\nexport function inject(route, values) {\n\treturn route.replace(RGX, (x, lead, key, optional) => {\n\t\tx = values[key=='*' ? 'wild' : key.substring(1)];\n\t\treturn x ? '/'+x : (optional || key=='*') ? '' : '/' + key;\n\t});\n}\n", "<script context=\"module\">\nimport {readable, writable, derived} from 'svelte/store'\nimport {tick} from 'svelte'\n\n/**\n * @typedef {Object} Location\n * @property {string} location - Location (page/view), for example `/book`\n * @property {string} [querystring] - Querystring from the hash, as a string not parsed\n */\n/**\n * Returns the current location from the hash.\n *\n * @returns {Location} Location object\n * @private\n */\nfunction getLocation() {\n    const hashPosition = window.location.href.indexOf('#/')\n    let location = (hashPosition > -1) ? window.location.href.substr(hashPosition + 1) : '/'\n\n    // Check if there's a querystring\n    const qsPosition = location.indexOf('?')\n    let querystring = ''\n    if (qsPosition > -1) {\n        querystring = location.substr(qsPosition + 1)\n        location = location.substr(0, qsPosition)\n    }\n\n    return {location, querystring}\n}\n\n/**\n * Readable store that returns the current full location (incl. querystring)\n */\nexport const loc = readable(\n    null,\n    // eslint-disable-next-line prefer-arrow-callback\n    function start(set) {\n        set(getLocation())\n\n        const update = () => {\n            set(getLocation())\n        }\n        window.addEventListener('hashchange', update, false)\n\n        return function stop() {\n            window.removeEventListener('hashchange', update, false)\n        }\n    }\n)\n\n/**\n * Readable store that returns the current location\n */\nexport const location = derived(\n    loc,\n    (_loc) => _loc.location\n)\n\n/**\n * Readable store that returns the current querystring\n */\nexport const querystring = derived(\n    loc,\n    (_loc) => _loc.querystring\n)\n\n/**\n * Store that returns the currently-matched params.\n * Despite this being writable, consumers should not change the value of the store.\n * It is exported as a readable store only (in the typings file)\n */\nexport const params = writable(undefined)\n\n/**\n * Navigates to a new page programmatically.\n *\n * @param {string} location - Path to navigate to (must start with `/` or '#/')\n * @return {Promise<void>} Promise that resolves after the page navigation has completed\n */\nexport async function push(location) {\n    if (!location || location.length < 1 || (location.charAt(0) != '/' && location.indexOf('#/') !== 0)) {\n        throw Error('Invalid parameter location')\n    }\n\n    // Execute this code when the current call stack is complete\n    await tick()\n\n    // Note: this will include scroll state in history even when restoreScrollState is false\n    history.replaceState({...history.state, __svelte_spa_router_scrollX: window.scrollX, __svelte_spa_router_scrollY: window.scrollY}, undefined)      \n    window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location\n}\n\n/**\n * Navigates back in history (equivalent to pressing the browser's back button).\n * \n * @return {Promise<void>} Promise that resolves after the page navigation has completed\n */\nexport async function pop() {\n    // Execute this code when the current call stack is complete\n    await tick()\n\n    window.history.back()\n}\n\n/**\n * Replaces the current page but without modifying the history stack.\n *\n * @param {string} location - Path to navigate to (must start with `/` or '#/')\n * @return {Promise<void>} Promise that resolves after the page navigation has completed\n */\nexport async function replace(location) {\n    if (!location || location.length < 1 || (location.charAt(0) != '/' && location.indexOf('#/') !== 0)) {\n        throw Error('Invalid parameter location')\n    }\n\n    // Execute this code when the current call stack is complete\n    await tick()\n\n    const dest = (location.charAt(0) == '#' ? '' : '#') + location\n    try {\n        const newState = {\n            ...history.state\n        }\n        delete newState['__svelte_spa_router_scrollX']\n        delete newState['__svelte_spa_router_scrollY']\n        window.history.replaceState(newState, undefined, dest)\n    }\n    catch (e) {\n        // eslint-disable-next-line no-console\n        console.warn('Caught exception while replacing the current page. If you\\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.')\n    }\n\n    // The method above doesn't trigger the hashchange event, so let's do that manually\n    window.dispatchEvent(new Event('hashchange'))\n}\n\n/**\n * Dictionary with options for the link action.\n * @typedef {Object} LinkActionOpts\n * @property {string} href - A string to use in place of the link's href attribute. Using this allows for updating link's targets reactively.\n * @property {boolean} disabled - If true, link is disabled\n */\n\n/**\n * Svelte Action that enables a link element (`<a>`) to use our history management.\n *\n * For example:\n *\n * ````html\n * <a href=\"/books\" use:link>View books</a>\n * ````\n *\n * @param {HTMLElement} node - The target node (automatically set by Svelte). Must be an anchor tag (`<a>`) with a href attribute starting in `/`\n * @param {string|LinkActionOpts} opts - Options object. For legacy reasons, we support a string too which will be the value for opts.href\n */\nexport function link(node, opts) {\n    opts = linkOpts(opts)\n\n    // Only apply to <a> tags\n    if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {\n        throw Error('Action \"link\" can only be used with <a> tags')\n    }\n\n    updateLink(node, opts)\n\n    return {\n        update(updated) {\n            updated = linkOpts(updated)\n            updateLink(node, updated)\n        }\n    }\n}\n\n/**\n * Tries to restore the scroll state from the given history state.\n *\n * @param {{__svelte_spa_router_scrollX: number, __svelte_spa_router_scrollY: number}} [state] - The history state to restore from.\n */\nexport function restoreScroll(state) {\n    // If this exists, then this is a back navigation: restore the scroll position\n    if (state) {\n        window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY)\n    }\n    else {\n        // Otherwise this is a forward navigation: scroll to top\n        window.scrollTo(0, 0)\n    }\n}\n\n// Internal function used by the link function\nfunction updateLink(node, opts) {\n    let href = opts.href || node.getAttribute('href')\n\n    // Destination must start with '/' or '#/'\n    if (href && href.charAt(0) == '/') {\n        // Add # to the href attribute\n        href = '#' + href\n    }\n    else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {\n        throw Error('Invalid value for \"href\" attribute: ' + href)\n    }\n\n    node.setAttribute('href', href)\n    node.addEventListener('click', (event) => {\n        // Prevent default anchor onclick behaviour\n        event.preventDefault()\n        if (!opts.disabled) {\n            scrollstateHistoryHandler(event.currentTarget.getAttribute('href'))\n        }\n    })\n}\n\n// Internal function that ensures the argument of the link action is always an object\nfunction linkOpts(val) {\n    if (val && typeof val == 'string') {\n        return {\n            href: val\n        }\n    }\n    else {\n        return val || {}\n    }\n}\n\n/**\n * The handler attached to an anchor tag responsible for updating the\n * current history state with the current scroll state\n *\n * @param {string} href - Destination\n */\nfunction scrollstateHistoryHandler(href) {\n    // Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that\n    history.replaceState({...history.state, __svelte_spa_router_scrollX: window.scrollX, __svelte_spa_router_scrollY: window.scrollY}, undefined)\n    // This will force an update as desired, but this time our scroll state will be attached\n    window.location.hash = href\n}\n</script>\n\n{#if componentParams}\n    <svelte:component\n    this={component}\n    params={componentParams}\n    on:routeEvent\n    {...props}\n    />\n{:else}\n    <svelte:component\n    this={component}\n    on:routeEvent\n    {...props}\n    />\n{/if}\n\n<script>\nimport {onDestroy, createEventDispatcher, afterUpdate} from 'svelte'\nimport {parse} from 'regexparam'\n\n/**\n * Dictionary of all routes, in the format `'/path': component`.\n *\n * For example:\n * ````js\n * import HomeRoute from './routes/HomeRoute.svelte'\n * import BooksRoute from './routes/BooksRoute.svelte'\n * import NotFoundRoute from './routes/NotFoundRoute.svelte'\n * routes = {\n *     '/': HomeRoute,\n *     '/books': BooksRoute,\n *     '*': NotFoundRoute\n * }\n * ````\n */\nexport let routes = {}\n\n/**\n * Optional prefix for the routes in this router. This is useful for example in the case of nested routers.\n */\nexport let prefix = ''\n\n/**\n * If set to true, the router will restore scroll positions on back navigation\n * and scroll to top on forward navigation.\n */\nexport let restoreScrollState = false\n\n/**\n * Container for a route: path, component\n */\nclass RouteItem {\n    /**\n     * Initializes the object and creates a regular expression from the path, using regexparam.\n     *\n     * @param {string} path - Path to the route (must start with '/' or '*')\n     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped\n     */\n    constructor(path, component) {\n        if (!component || (typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true))) {\n            throw Error('Invalid component object')\n        }\n\n        // Path must be a regular or expression, or a string starting with '/' or '*'\n        if (!path || \n            (typeof path == 'string' && (path.length < 1 || (path.charAt(0) != '/' && path.charAt(0) != '*'))) ||\n            (typeof path == 'object' && !(path instanceof RegExp))\n        ) {\n            throw Error('Invalid value for \"path\" argument - strings must start with / or *')\n        }\n\n        const {pattern, keys} = parse(path)\n\n        this.path = path\n\n        // Check if the component is wrapped and we have conditions\n        if (typeof component == 'object' && component._sveltesparouter === true) {\n            this.component = component.component\n            this.conditions = component.conditions || []\n            this.userData = component.userData\n            this.props = component.props || {}\n        }\n        else {\n            // Convert the component to a function that returns a Promise, to normalize it\n            this.component = () => Promise.resolve(component)\n            this.conditions = []\n            this.props = {}\n        }\n\n        this._pattern = pattern\n        this._keys = keys\n    }\n\n    /**\n     * Checks if `path` matches the current route.\n     * If there's a match, will return the list of parameters from the URL (if any).\n     * In case of no match, the method will return `null`.\n     *\n     * @param {string} path - Path to test\n     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.\n     */\n    match(path) {\n        // If there's a prefix, check if it matches the start of the path.\n        // If not, bail early, else remove it before we run the matching.\n        if (prefix) {\n            if (typeof prefix == 'string') {\n                if (path.startsWith(prefix)) {\n                    path = path.substr(prefix.length) || '/'\n                }\n                else {\n                    return null\n                }\n            }\n            else if (prefix instanceof RegExp) {\n                const match = path.match(prefix)\n                if (match && match[0]) {\n                    path = path.substr(match[0].length) || '/'\n                }\n                else {\n                    return null\n                }\n            }\n        }\n\n        // Check if the pattern matches\n        const matches = this._pattern.exec(path)\n        if (matches === null) {\n            return null\n        }\n\n        // If the input was a regular expression, this._keys would be false, so return matches as is\n        if (this._keys === false) {\n            return matches\n        }\n\n        const out = {}\n        let i = 0\n        while (i < this._keys.length) {\n            // In the match parameters, URL-decode all values\n            try {\n                out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null\n            }\n            catch (e) {\n                out[this._keys[i]] = null\n            }\n            i++\n        }\n        return out\n    }\n\n    /**\n     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events\n     * @typedef {Object} RouteDetail\n     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)\n     * @property {string} location - Location path\n     * @property {string} querystring - Querystring from the hash\n     * @property {object} [userData] - Custom data passed by the user\n     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)\n     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)\n     */\n\n    /**\n     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.\n     * \n     * @param {RouteDetail} detail - Route detail\n     * @returns {boolean} Returns true if all the conditions succeeded\n     */\n    async checkConditions(detail) {\n        for (let i = 0; i < this.conditions.length; i++) {\n            if (!(await this.conditions[i](detail))) {\n                return false\n            }\n        }\n\n        return true\n    }\n}\n\n// Set up all routes\nconst routesList = []\nif (routes instanceof Map) {\n    // If it's a map, iterate on it right away\n    routes.forEach((route, path) => {\n        routesList.push(new RouteItem(path, route))\n    })\n}\nelse {\n    // We have an object, so iterate on its own properties\n    Object.keys(routes).forEach((path) => {\n        routesList.push(new RouteItem(path, routes[path]))\n    })\n}\n\n// Props for the component to render\nlet component = null\nlet componentParams = null\nlet props = {}\n\n// Event dispatcher from Svelte\nconst dispatch = createEventDispatcher()\n\n// Just like dispatch, but executes on the next iteration of the event loop\nasync function dispatchNextTick(name, detail) {\n    // Execute this code when the current call stack is complete\n    await tick()\n    dispatch(name, detail)\n}\n\n// If this is set, then that means we have popped into this var the state of our last scroll position\nlet previousScrollState = null\n\n// Update history.scrollRestoration depending on restoreScrollState\n$: history.scrollRestoration = restoreScrollState ? 'manual' : 'auto'\nlet popStateChanged = null\nif (restoreScrollState) {\n    popStateChanged = (event) => {\n        // If this event was from our history.replaceState, event.state will contain\n        // our scroll history. Otherwise, event.state will be null (like on forward\n        // navigation)\n        if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {\n            previousScrollState = event.state\n        }\n        else {\n            previousScrollState = null\n        }\n    }\n    // This is removed in the destroy() invocation below\n    window.addEventListener('popstate', popStateChanged)\n\n    afterUpdate(() => {\n        restoreScroll(previousScrollState)\n    })\n}\n\n// Always have the latest value of loc\nlet lastLoc = null\n\n// Current object of the component loaded\nlet componentObj = null\n\n// Handle hash change events\n// Listen to changes in the $loc store and update the page\n// Do not use the $: syntax because it gets triggered by too many things\nconst unsubscribeLoc = loc.subscribe(async (newLoc) => {\n    lastLoc = newLoc\n\n    // Find a route matching the location\n    let i = 0\n    while (i < routesList.length) {\n        const match = routesList[i].match(newLoc.location)\n        if (!match) {\n            i++\n            continue\n        }\n\n        const detail = {\n            route: routesList[i].path,\n            location: newLoc.location,\n            querystring: newLoc.querystring,\n            userData: routesList[i].userData,\n            params: (match && typeof match == 'object' && Object.keys(match).length) ? match : null\n        }\n\n        // Check if the route can be loaded - if all conditions succeed\n        if (!(await routesList[i].checkConditions(detail))) {\n            // Don't display anything\n            component = null\n            componentObj = null\n            // Trigger an event to notify the user, then exit\n            dispatchNextTick('conditionsFailed', detail)\n            return\n        }\n\n        // Trigger an event to alert that we're loading the route\n        // We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick\n        dispatchNextTick('routeLoading', Object.assign({}, detail))\n\n        // If there's a component to show while we're loading the route, display it\n        const obj = routesList[i].component\n        // Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted\n        if (componentObj != obj) {\n            if (obj.loading) {\n                component = obj.loading\n                componentObj = obj\n                componentParams = obj.loadingParams\n                props = {}\n\n                // Trigger the routeLoaded event for the loading component\n                // Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)\n                dispatchNextTick('routeLoaded', Object.assign({}, detail, {\n                    component: component,\n                    name: component.name,\n                    params: componentParams\n                }))\n            }\n            else {\n                component = null\n                componentObj = null\n            }\n\n            // Invoke the Promise\n            const loaded = await obj()\n\n            // Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile\n            if (newLoc != lastLoc) {\n                // Don't update the component, just exit\n                return\n            }\n\n            // If there is a \"default\" property, which is used by async routes, then pick that\n            component = (loaded && loaded.default) || loaded\n            componentObj = obj\n        }\n\n        // Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`\n        // Of course, this assumes that developers always add a \"params\" prop when they are expecting parameters\n        if (match && typeof match == 'object' && Object.keys(match).length) {\n            componentParams = match\n        }\n        else {\n            componentParams = null\n        }\n\n        // Set static props, if any\n        props = routesList[i].props\n\n        // Dispatch the routeLoaded event then exit\n        // We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick\n        dispatchNextTick('routeLoaded', Object.assign({}, detail, {\n            component: component,\n            name: component.name,\n            params: componentParams\n        })).then(() => {\n            params.set(componentParams)\n        })\n        return\n    }\n\n    // If we're still here, there was no match, so show the empty component\n    component = null\n    componentObj = null\n    params.set(undefined)\n})\n\nonDestroy(() => {\n    unsubscribeLoc()\n    popStateChanged && window.removeEventListener('popstate', popStateChanged)\n})\n</script>\n"],
  "mappings": "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",
  "names": ["location", "querystring", "set", "push", "pop", "component", "$$anchor"]
}
