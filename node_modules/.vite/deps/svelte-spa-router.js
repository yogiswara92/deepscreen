import "./chunk-7ZVBUELO.js";
import "./chunk-SPSHIHV7.js";
import {
  afterUpdate,
  bubble_event,
  check_target,
  component,
  createEventDispatcher,
  derived,
  hmr,
  if_block,
  init,
  legacy_api,
  onDestroy,
  prop,
  readable,
  spread_props,
  writable
} from "./chunk-64UJFCJM.js";
import {
  append,
  comment
} from "./chunk-AK4QHSZL.js";
import {
  FILENAME,
  HMR,
  deep_read_state,
  equals,
  first_child,
  get,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  pop,
  push,
  set,
  strict_equals,
  tick
} from "./chunk-RH3YGK5U.js";
import "./chunk-DM772GTT.js";
import "./chunk-USYKAB3S.js";
import "./chunk-RIXFT5AQ.js";
import "./chunk-RVAV4ZRS.js";
import "./chunk-NNIHVWYK.js";

// node_modules/regexparam/dist/index.mjs
function parse(str, loose) {
  if (str instanceof RegExp) return { keys: false, pattern: str };
  var c, o, tmp, ext, keys = [], pattern = "", arr = str.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys.push("wild");
      pattern += "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext) pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys,
    pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
  };
}

// node_modules/svelte-spa-router/Router.svelte
Router[FILENAME] = "node_modules/svelte-spa-router/Router.svelte";
function getLocation() {
  const hashPosition = window.location.href.indexOf("#/");
  let location2 = hashPosition > -1 ? window.location.href.substr(hashPosition + 1) : "/";
  const qsPosition = location2.indexOf("?");
  let querystring2 = "";
  if (qsPosition > -1) {
    querystring2 = location2.substr(qsPosition + 1);
    location2 = location2.substr(0, qsPosition);
  }
  return { location: location2, querystring: querystring2 };
}
var loc = readable(
  null,
  // eslint-disable-next-line prefer-arrow-callback
  function start(set2) {
    set2(getLocation());
    const update = () => {
      set2(getLocation());
    };
    window.addEventListener("hashchange", update, false);
    return function stop() {
      window.removeEventListener("hashchange", update, false);
    };
  }
);
var location = derived(loc, (_loc) => _loc.location);
var querystring = derived(loc, (_loc) => _loc.querystring);
var params = writable(void 0);
async function push2(location2) {
  if (!location2 || location2.length < 1 || equals(location2.charAt(0), "/", false) && strict_equals(location2.indexOf("#/"), 0, false)) {
    throw Error("Invalid parameter location");
  }
  await tick();
  history.replaceState(
    {
      ...history.state,
      __svelte_spa_router_scrollX: window.scrollX,
      __svelte_spa_router_scrollY: window.scrollY
    },
    void 0
  );
  window.location.hash = (equals(location2.charAt(0), "#") ? "" : "#") + location2;
}
async function pop2() {
  await tick();
  window.history.back();
}
async function replace(location2) {
  if (!location2 || location2.length < 1 || equals(location2.charAt(0), "/", false) && strict_equals(location2.indexOf("#/"), 0, false)) {
    throw Error("Invalid parameter location");
  }
  await tick();
  const dest = (equals(location2.charAt(0), "#") ? "" : "#") + location2;
  try {
    const newState = { ...history.state };
    delete newState["__svelte_spa_router_scrollX"];
    delete newState["__svelte_spa_router_scrollY"];
    window.history.replaceState(newState, void 0, dest);
  } catch (e) {
    console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
  }
  window.dispatchEvent(new Event("hashchange"));
}
function link(node, opts) {
  opts = linkOpts(opts);
  if (!node || !node.tagName || equals(node.tagName.toLowerCase(), "a", false)) {
    throw Error('Action "link" can only be used with <a> tags');
  }
  updateLink(node, opts);
  return {
    update(updated) {
      updated = linkOpts(updated);
      updateLink(node, updated);
    }
  };
}
function restoreScroll(state) {
  if (state) {
    window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY);
  } else {
    window.scrollTo(0, 0);
  }
}
function updateLink(node, opts) {
  let href = opts.href || node.getAttribute("href");
  if (href && equals(href.charAt(0), "/")) {
    href = "#" + href;
  } else if (!href || href.length < 2 || equals(href.slice(0, 2), "#/", false)) {
    throw Error('Invalid value for "href" attribute: ' + href);
  }
  node.setAttribute("href", href);
  node.addEventListener("click", (event) => {
    event.preventDefault();
    if (!opts.disabled) {
      scrollstateHistoryHandler(event.currentTarget.getAttribute("href"));
    }
  });
}
function linkOpts(val) {
  if (val && equals(typeof val, "string")) {
    return { href: val };
  } else {
    return val || {};
  }
}
function scrollstateHistoryHandler(href) {
  history.replaceState(
    {
      ...history.state,
      __svelte_spa_router_scrollX: window.scrollX,
      __svelte_spa_router_scrollY: window.scrollY
    },
    void 0
  );
  window.location.hash = href;
}
function Router($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Router);
  let routes = prop($$props, "routes", 24, () => ({}));
  let prefix = prop($$props, "prefix", 8, "");
  let restoreScrollState = prop($$props, "restoreScrollState", 8, false);
  class RouteItem {
    /**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    constructor(path, component3) {
      if (!component3 || equals(typeof component3, "function", false) && (equals(typeof component3, "object", false) || strict_equals(component3._sveltesparouter, true, false))) {
        throw Error("Invalid component object");
      }
      if (!path || equals(typeof path, "string") && (path.length < 1 || equals(path.charAt(0), "/", false) && equals(path.charAt(0), "*", false)) || equals(typeof path, "object") && !(path instanceof RegExp)) {
        throw Error('Invalid value for "path" argument - strings must start with / or *');
      }
      const { pattern, keys } = parse(path);
      this.path = path;
      if (equals(typeof component3, "object") && strict_equals(component3._sveltesparouter, true)) {
        this.component = component3.component;
        this.conditions = component3.conditions || [];
        this.userData = component3.userData;
        this.props = component3.props || {};
      } else {
        this.component = () => Promise.resolve(component3);
        this.conditions = [];
        this.props = {};
      }
      this._pattern = pattern;
      this._keys = keys;
    }
    /**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    match(path) {
      if (prefix()) {
        if (equals(typeof prefix(), "string")) {
          if (path.startsWith(prefix())) {
            path = path.substr(prefix().length) || "/";
          } else {
            return null;
          }
        } else if (prefix() instanceof RegExp) {
          const match = path.match(prefix());
          if (match && match[0]) {
            path = path.substr(match[0].length) || "/";
          } else {
            return null;
          }
        }
      }
      const matches = this._pattern.exec(path);
      if (strict_equals(matches, null)) {
        return null;
      }
      if (strict_equals(this._keys, false)) {
        return matches;
      }
      const out = {};
      let i = 0;
      while (i < this._keys.length) {
        try {
          out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
        } catch (e) {
          out[this._keys[i]] = null;
        }
        i++;
      }
      return out;
    }
    /**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    /**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    async checkConditions(detail) {
      for (let i = 0; i < this.conditions.length; i++) {
        if (!await this.conditions[i](detail)) {
          return false;
        }
      }
      return true;
    }
  }
  const routesList = [];
  if (routes() instanceof Map) {
    routes().forEach((route, path) => {
      routesList.push(new RouteItem(path, route));
    });
  } else {
    Object.keys(routes()).forEach((path) => {
      routesList.push(new RouteItem(path, routes()[path]));
    });
  }
  let component2 = mutable_source(null);
  let componentParams = mutable_source(null);
  let props = mutable_source({});
  const dispatch = createEventDispatcher();
  async function dispatchNextTick(name, detail) {
    await tick();
    dispatch(name, detail);
  }
  let previousScrollState = null;
  let popStateChanged = null;
  if (restoreScrollState()) {
    popStateChanged = (event) => {
      if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {
        previousScrollState = event.state;
      } else {
        previousScrollState = null;
      }
    };
    window.addEventListener("popstate", popStateChanged);
    afterUpdate(() => {
      restoreScroll(previousScrollState);
    });
  }
  let lastLoc = null;
  let componentObj = null;
  const unsubscribeLoc = loc.subscribe(async (newLoc) => {
    lastLoc = newLoc;
    let i = 0;
    while (i < routesList.length) {
      const match = routesList[i].match(newLoc.location);
      if (!match) {
        i++;
        continue;
      }
      const detail = {
        route: routesList[i].path,
        location: newLoc.location,
        querystring: newLoc.querystring,
        userData: routesList[i].userData,
        params: match && equals(typeof match, "object") && Object.keys(match).length ? match : null
      };
      if (!await routesList[i].checkConditions(detail)) {
        set(component2, null);
        componentObj = null;
        dispatchNextTick("conditionsFailed", detail);
        return;
      }
      dispatchNextTick("routeLoading", Object.assign({}, detail));
      const obj = routesList[i].component;
      if (equals(componentObj, obj, false)) {
        if (obj.loading) {
          set(component2, obj.loading);
          componentObj = obj;
          set(componentParams, obj.loadingParams);
          set(props, {});
          dispatchNextTick("routeLoaded", Object.assign({}, detail, {
            component: get(component2),
            name: get(component2).name,
            params: get(componentParams)
          }));
        } else {
          set(component2, null);
          componentObj = null;
        }
        const loaded = await obj();
        if (equals(newLoc, lastLoc, false)) {
          return;
        }
        set(component2, loaded && loaded.default || loaded);
        componentObj = obj;
      }
      if (match && equals(typeof match, "object") && Object.keys(match).length) {
        set(componentParams, match);
      } else {
        set(componentParams, null);
      }
      set(props, routesList[i].props);
      dispatchNextTick("routeLoaded", Object.assign({}, detail, {
        component: get(component2),
        name: get(component2).name,
        params: get(componentParams)
      })).then(() => {
        params.set(get(componentParams));
      });
      return;
    }
    set(component2, null);
    componentObj = null;
    params.set(void 0);
  });
  onDestroy(() => {
    unsubscribeLoc();
    popStateChanged && window.removeEventListener("popstate", popStateChanged);
  });
  legacy_pre_effect(
    () => deep_read_state(restoreScrollState()),
    () => {
      history.scrollRestoration = restoreScrollState() ? "manual" : "auto";
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      component(node_2, () => get(component2), ($$anchor3, $$component) => {
        $$component($$anchor3, spread_props(
          {
            get params() {
              return get(componentParams);
            }
          },
          () => get(props),
          {
            $$events: {
              routeEvent($$arg) {
                bubble_event.call(this, $$props, $$arg);
              }
            }
          }
        ));
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      component(node_3, () => get(component2), ($$anchor3, $$component) => {
        $$component($$anchor3, spread_props(() => get(props), {
          $$events: {
            routeEvent($$arg) {
              bubble_event.call(this, $$props, $$arg);
            }
          }
        }));
      });
      append($$anchor2, fragment_2);
    };
    if_block(node_1, ($$render) => {
      if (get(componentParams)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Router = hmr(Router, () => Router[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Router[HMR].source;
    set(Router[HMR].source, module.default[HMR].original);
  });
}
var Router_default = Router;
export {
  Router_default as default,
  link,
  loc,
  location,
  params,
  pop2 as pop,
  push2 as push,
  querystring,
  replace,
  restoreScroll
};
//# sourceMappingURL=svelte-spa-router.js.map
